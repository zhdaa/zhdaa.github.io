<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="zhendong在github上的个人博客">
    <meta name="keyword" content="">
    <meta name="theme-color" content="#600090">
    <meta name="msapplication-navbutton-color" content="#600090">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="#600090">
    <link rel="shortcut icon" href="/images/favicon.ico">
    <link rel="alternate" type="application/atom+xml" title="Zhendong" href="/atom.xml">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css">
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.css">
    <title>
        
        我的C#学习笔记（五）多线程和Socket网络编程｜Zhendong&#39;s blog
        
    </title>

    <link rel="canonical" href="https://zhdaa.github.io/2018/09/27/我的C-学习笔记（五）多线程和Socket网络编程/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/blog-style.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">
</head>

<style>

    header.intro-header {
        background-image: url('/images/zhdaa-headimg.jpg')
    }
</style>
<!-- hack iOS CSS :active style -->
<body ontouchstart="" class="animated fadeIn">
<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top " id="nav-top" data-ispost = "true" data-istags="false
" data-ishome = "false" >
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand animated pulse" href="/">
                <span class="brand-logo">
                    Zhendong
                </span>
                's Blog
            </a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <!-- /.navbar-collapse -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
					
                    
                        
							
                        <li>
                            <a href="/Tags/">Tags</a>
                        </li>
							
						
                    
					
					
                </ul>
            </div>
        </div>
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
//    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>

<!-- Main Content -->

<!--only post-->


<img class="wechat-title-img"
     src="/images/post-ocean.jpg">


<style>
    
    header.intro-header {
        background-image: url('/images/post-ocean.jpg')
    }

    
</style>

<header class="intro-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <div class="post-heading">
                    <h1>我的C#学习笔记（五）多线程和Socket网络编程</h1>
                    
                    <span class="meta">
                         作者 Zhendong Ho
                        <span>
                          日期 2018-09-27
                         </span>
                    </span>
                    <div class="tags text-center">
                        
                        <a class="tag" href="/tags/#C#"
                           title="C#">C#</a>
                        
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="post-title-haojen">
        <span>
            我的C#学习笔记（五）多线程和Socket网络编程
        </span>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <!-- Post Container -->
            <div class="col-lg-8 col-lg-offset-1 col-sm-9 post-container">
                <h2 id="进程类"><a href="#进程类" class="headerlink" title="进程类"></a>进程类</h2><h3 id="获得所有的进程"><a href="#获得所有的进程" class="headerlink" title="获得所有的进程"></a>获得所有的进程</h3><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获得当前程序中所有正在运行的进程</span></span><br><span class="line">Process[] pros = Process.GetProcesses();</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> pros)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//杀死进程</span></span><br><span class="line">    <span class="comment">//item.Kill();</span></span><br><span class="line">    Console.WriteLine(item);</span><br><span class="line">&#125;</span><br><span class="line">Console.ReadKey();</span><br></pre></td></tr></table></figure>
<h3 id="通过进程打开应用程序"><a href="#通过进程打开应用程序" class="headerlink" title="通过进程打开应用程序"></a>通过进程打开应用程序</h3><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过进程打开一些应用程序</span></span><br><span class="line">Process.Start(<span class="string">"calc"</span>);<span class="comment">//计算器</span></span><br><span class="line">Process.Start(<span class="string">"mspaint"</span>);<span class="comment">//画图</span></span><br><span class="line">Process.Start(<span class="string">"notepad"</span>);<span class="comment">//记事本</span></span><br><span class="line">Process.Start(<span class="string">"iexplore"</span>, <span class="string">"https://www.baidu.com"</span>);<span class="comment">//ie</span></span><br></pre></td></tr></table></figure>
<h3 id="通过进程打开指定文件"><a href="#通过进程打开指定文件" class="headerlink" title="通过进程打开指定文件"></a>通过进程打开指定文件</h3><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过一个进程打开指定的文件</span></span><br><span class="line">ProcessStartInfo psi = <span class="keyword">new</span> ProcessStartInfo(<span class="string">@"D:\a.txt"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建进程对象</span></span><br><span class="line">Process p = <span class="keyword">new</span> Process();</span><br><span class="line">p.StartInfo = psi;</span><br><span class="line">p.Start();</span><br></pre></td></tr></table></figure>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="单线程带来的问题"><a href="#单线程带来的问题" class="headerlink" title="单线程带来的问题"></a>单线程带来的问题</h3><p>程序在同时做多件事情的时候，会出现卡死状态。</p>
<h3 id="为什么要用多线程"><a href="#为什么要用多线程" class="headerlink" title="为什么要用多线程"></a>为什么要用多线程</h3><ul>
<li>让计算机同时做多件事情，节约时间。</li>
<li>多线程可以让一个程序同时处理多个事情。</li>
<li>后台运行程序，提高程序的运行效率，也不会使主界面出现无响应的情况。</li>
<li>获得当前线程和当前进程。</li>
</ul>
<h3 id="前台线程和后台线程"><a href="#前台线程和后台线程" class="headerlink" title="前台线程和后台线程"></a>前台线程和后台线程</h3><p>前台线程：只有所有的前台线程都关闭才能完成程序关闭。</p>
<p>后台线程：只要所有的前台线程结束，后台线程自动结束。</p>
<h3 id="产生线程的步骤"><a href="#产生线程的步骤" class="headerlink" title="产生线程的步骤"></a>产生线程的步骤</h3><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个线程去执行这个方法</span></span><br><span class="line">Thread th = <span class="keyword">new</span> Thread(Test);</span><br><span class="line"><span class="comment">//将线程设置为后台线程</span></span><br><span class="line">th.IsBackground = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//标记这个线程准备就绪了，可以随时被执行。具体什么时候执行这个线程，由CPU决定</span></span><br><span class="line">th.Start();</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：调用Thread实例的Start方法，标记该线程可以被CPU执行了，但具体执行时间由CPU决定。</p>
<h3 id="跨线程访问"><a href="#跨线程访问" class="headerlink" title="跨线程访问"></a>跨线程访问</h3><p>在.NET下，是不允许跨线程访问的。</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="comment">//由于textBox1是由主线程创建的，该方法由新创建的线程执行，这里操作textBox1是跨线程访问。</span></span><br><span class="line">        textBox1.Text = i.ToString();<span class="comment">//报错，线程间的操作无效，从不是创建控件“textBox1”的线程访问它。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决方法，不让程序检查到跨线程访问</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取消跨线程访问</span></span><br><span class="line">Control.CheckForIllegalCrossThreadCalls = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>在WPF中，解决跨线程访问的问题</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">Dispatcher.BeginInvoke(DispatcherPriority.Normal, <span class="keyword">new</span> delegate1(ShowMsg), socketSend.RemoteEndPoint.ToString() + <span class="string">":"</span> + <span class="string">"连接成功"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="Thread类的重要成员"><a href="#Thread类的重要成员" class="headerlink" title="Thread类的重要成员"></a>Thread类的重要成员</h3><ul>
<li>Start()启动线程，告诉CPU线程可以被执行，具体什么时候执行，由CPU决定。</li>
<li>Abort()终止线程，终止完成之后不能再Start()。</li>
<li>Thread.Sleep(1)，静态方法，可以使当前线程停止一段时间运行。</li>
<li>Name线程名。</li>
<li>Thread.CurrentThread获得当前的线程引用。</li>
</ul>
<h2 id="Socket网络编程"><a href="#Socket网络编程" class="headerlink" title="Socket网络编程"></a>Socket网络编程</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>socket的英文原义是“孔”或“插座”。作为进程通信机制，通常称为“套接字”，用于描述IP地址和端口号，是一个通信链的句柄。（其实就是两个程序通信用的）</p>
<h3 id="TCP和UDP协议"><a href="#TCP和UDP协议" class="headerlink" title="TCP和UDP协议"></a>TCP和UDP协议</h3><p>TCP：3次握手，必须要有服务器。特点是安全，稳定，但是效率低。</p>
<p>UDP：快速，效率高，但是不稳定，容易发生数据丢失。</p>
<h3 id="服务端Server"><a href="#服务端Server" class="headerlink" title="服务端Server"></a>服务端Server</h3><p><img src="1538764982173.png" alt="1538764982173"></p>
<h4 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h4><ol>
<li>点击开始监听时，在服务器端创建一个负责监听的Socket。通过IPAddress.Any或手动配置IP的方式，创建IP和端口号并绑定。</li>
<li>新建一个线程，等待客户端的连接，并创建与之通信的Socket。（解决等待连接时，程序假死状态的问题）</li>
<li>在监听的过程中，新建一个线程，不停地接收客户端发送过来的消息，并填充到相应对话框中。</li>
<li>点击发送消息按钮，将文本框中的内容以字节的方式发送给相应的负责通信的Socket对象。</li>
<li>点击选择按钮，打开文件对话框。选择要发送的文件后，将文件的路径填充到TextBox中。</li>
<li>点击发送文件按钮，将要发送文件的路径用FileStream读取，以字节的方式发送给相应的负责通信的Socket对象。</li>
<li>点击震动按钮，发送震动信息（buffer[0]的值为2）给相应的负责通信的Socket对象。</li>
</ol>
<p><strong>注意</strong>：</p>
<ul>
<li>socketWatch.Listen(10);的作用是，限制监听的数量，超出的连接需要排队等待。</li>
<li>新建线程处理的目的是为了解决程序假死的问题。</li>
<li>解决跨线程访问的问题，要用Dispatcher.BeginInvoke（需要定义委托）。</li>
<li>使用try-catch语句，其中catch为空。效果是程序出现异常时，不做任何操作，看起来就像没有异常一样。</li>
<li>使用Dictionary&lt;string, Socket&gt;将远程连接的IP地址和Socket存入集合中，可以使服务端给不同的客户端发送消息。</li>
<li>服务端发送不同类型的消息给客户端时，定义一套协议。发送消息为0，发送文件为1，发送震动为2。</li>
</ul>
<h4 id="创建负责监听的Socket"><a href="#创建负责监听的Socket" class="headerlink" title="创建负责监听的Socket"></a>创建负责监听的Socket</h4><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">btnListen_Click</span>(<span class="params"><span class="keyword">object</span> sender, RoutedEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当点击开始监听的时候，在服务器端创建一个负责监听IP地址跟端口号的Socket</span></span><br><span class="line">        Socket socketWatch = <span class="keyword">new</span> Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);</span><br><span class="line">        IPAddress ip = IPAddress.Parse(<span class="string">"192.168.0.102"</span>);<span class="comment">//IPAddress.Any;</span></span><br><span class="line">        <span class="comment">//创建端口号对象</span></span><br><span class="line">        IPEndPoint point = <span class="keyword">new</span> IPEndPoint(ip, Convert.ToInt32(txtPort.Text));</span><br><span class="line">        <span class="comment">//监听</span></span><br><span class="line">        socketWatch.Bind(point);</span><br><span class="line">        ShowMsg(<span class="string">"监听成功"</span>);</span><br><span class="line">        socketWatch.Listen(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        Thread th = <span class="keyword">new</span> Thread(Listen);</span><br><span class="line">        th.IsBackground = <span class="literal">true</span>;</span><br><span class="line">        th.Start(socketWatch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="等待客户端连接，创建负责通信的Socket"><a href="#等待客户端连接，创建负责通信的Socket" class="headerlink" title="等待客户端连接，创建负责通信的Socket"></a>等待客户端连接，创建负责通信的Socket</h4><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 等待客户端的连接，并且创建与之通信的Socket</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="o"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Listen</span>(<span class="params"><span class="keyword">object</span> o</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Socket socketWatch = o <span class="keyword">as</span> Socket;</span><br><span class="line">    <span class="comment">//等待客户端的连接，并且创建一个负责通信的Socket</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//负责跟客户端通信的Socket</span></span><br><span class="line">            socketSend = socketWatch.Accept();</span><br><span class="line">            <span class="comment">//将远程连接的客户端的IP地址和Socket存入集合中</span></span><br><span class="line">            dicSocket.Add(socketSend.RemoteEndPoint.ToString(), socketSend);</span><br><span class="line">            <span class="comment">//将远程连接的客户端的IP地址和端口号存储下拉框中</span></span><br><span class="line">            <span class="comment">//cboUsers.Items.Add(socketSend.RemoteEndPoint.ToString());</span></span><br><span class="line">            Dispatcher.BeginInvoke(DispatcherPriority.Normal, <span class="keyword">new</span> delegate2(cboUsers.Items.Add), socketSend.RemoteEndPoint.ToString());</span><br><span class="line">            <span class="comment">//192.168.0.100:连接成功</span></span><br><span class="line">            Dispatcher.BeginInvoke(DispatcherPriority.Normal, <span class="keyword">new</span> delegate1(ShowMsg), socketSend.RemoteEndPoint.ToString() + <span class="string">":"</span> + <span class="string">"连接成功"</span>);</span><br><span class="line">            <span class="comment">//开启一个新的线程，不停地接收客户端发送过来的消息</span></span><br><span class="line">            Thread th = <span class="keyword">new</span> Thread(Receive);</span><br><span class="line">            th.IsBackground = <span class="literal">true</span>;</span><br><span class="line">            th.Start(socketSend);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="接收客户端发送的消息"><a href="#接收客户端发送的消息" class="headerlink" title="接收客户端发送的消息"></a>接收客户端发送的消息</h4><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Receive</span>(<span class="params"><span class="keyword">object</span> o</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Socket socketSend = o <span class="keyword">as</span> Socket;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//客户端连接成功后，服务器应该接收服务器应该接收客户端发来的消息</span></span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">2</span>];</span><br><span class="line">            <span class="comment">//实际接收到的有效字节数</span></span><br><span class="line">            <span class="keyword">int</span> r = socketSend.Receive(buffer);</span><br><span class="line">            <span class="keyword">if</span> (r == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">string</span> str = Encoding.UTF8.GetString(buffer, <span class="number">0</span>, r);</span><br><span class="line">            Dispatcher.BeginInvoke(DispatcherPriority.Normal, <span class="keyword">new</span> delegate1(ShowMsg), socketSend.RemoteEndPoint.ToString() + <span class="string">":"</span> + str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ShowMsg方法"><a href="#ShowMsg方法" class="headerlink" title="ShowMsg方法"></a>ShowMsg方法</h4><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ShowMsg</span>(<span class="params"><span class="keyword">string</span> str</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    txtContent.AppendText(str + <span class="string">"\r\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="服务器给客户端发送消息"><a href="#服务器给客户端发送消息" class="headerlink" title="服务器给客户端发送消息"></a>服务器给客户端发送消息</h4><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 服务器给客户端发送消息</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="sender"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="e"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">btnSendMsg_Click</span>(<span class="params"><span class="keyword">object</span> sender, RoutedEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span> str = txtSendMsg.Text.Trim();</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = Encoding.UTF8.GetBytes(str);</span><br><span class="line">    List&lt;<span class="keyword">byte</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="keyword">byte</span>&gt;();</span><br><span class="line">    list.Add(<span class="number">0</span>);</span><br><span class="line">    list.AddRange(buffer);</span><br><span class="line">    <span class="comment">//将泛型集合转换为数组</span></span><br><span class="line">    <span class="keyword">byte</span>[] newBuffer = list.ToArray();</span><br><span class="line">    <span class="comment">//获得用户在下拉框中选中的IP地址</span></span><br><span class="line">    <span class="keyword">string</span> ip = cboUsers.SelectedItem.ToString();</span><br><span class="line">    dicSocket[ip].Send(newBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="选择文件"><a href="#选择文件" class="headerlink" title="选择文件"></a>选择文件</h4><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 选择要发送的文件</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="sender"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="e"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">btnChooseFile_Click</span>(<span class="params"><span class="keyword">object</span> sender, RoutedEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    OpenFileDialog ofd = <span class="keyword">new</span> OpenFileDialog();</span><br><span class="line">    ofd.InitialDirectory = <span class="string">@"C:\Users\Administrator\Desktop"</span>;</span><br><span class="line">    ofd.Title = <span class="string">"请选择要发送的文件"</span>;</span><br><span class="line">    ofd.Filter = <span class="string">"所有文件|*.*"</span>;</span><br><span class="line">    ofd.ShowDialog();</span><br><span class="line"></span><br><span class="line">    txtFilePath.Text = ofd.FileName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="发送文件"><a href="#发送文件" class="headerlink" title="发送文件"></a>发送文件</h4><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">btnSendFile_Click</span>(<span class="params"><span class="keyword">object</span> sender, RoutedEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获得要发送文件的路径</span></span><br><span class="line">    <span class="keyword">string</span> path = txtFilePath.Text;</span><br><span class="line">    <span class="keyword">using</span> (FileStream fsRead = <span class="keyword">new</span> FileStream(path, FileMode.Open, FileAccess.Read))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">5</span>];</span><br><span class="line">        <span class="keyword">int</span> r = fsRead.Read(buffer, <span class="number">0</span>, buffer.Length);</span><br><span class="line">        List&lt;<span class="keyword">byte</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="keyword">byte</span>&gt;();</span><br><span class="line">        list.Add(<span class="number">1</span>);</span><br><span class="line">        list.AddRange(buffer);</span><br><span class="line">        <span class="keyword">byte</span>[] newBuffer = list.ToArray();</span><br><span class="line">        dicSocket[cboUsers.SelectedItem.ToString()].Send(newBuffer, <span class="number">0</span>, r + <span class="number">1</span>, SocketFlags.None);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="发送震动"><a href="#发送震动" class="headerlink" title="发送震动"></a>发送震动</h4><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 发送震动</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="sender"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="e"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">btnShock_Click</span>(<span class="params"><span class="keyword">object</span> sender, RoutedEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1</span>];</span><br><span class="line">    buffer[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">    dicSocket[cboUsers.SelectedItem.ToString()].Send(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="客户端Client"><a href="#客户端Client" class="headerlink" title="客户端Client"></a>客户端Client</h3><p><img src="1538765006046.png" alt="1538765006046"></p>
<h4 id="主要思路-1"><a href="#主要思路-1" class="headerlink" title="主要思路"></a>主要思路</h4><ol>
<li>点击连接按钮，创建负责通信的Socket，根据输入的IP地址和端口号，连接到远程服务器的应用程序。</li>
<li>开启一个新的线程，不停地接收服务器端发来的消息。并且对消息的类型进行判断（文本消息、文件、震动）。</li>
<li>点击发送消息按钮，客户端给服务器发送消息，原理和服务器给客户端发送消息一致。</li>
</ol>
<p><strong>注意</strong>：</p>
<ul>
<li>如果接收到服务器端发送来的是文件。打开保存文件对话框，使用FileStream以字节的方式写入文件。</li>
<li>接收服务器端发送的消息时，要忽略buffer[0]的标志位，即从1的位置开始解码，有效字节数为r-1个。</li>
</ul>
<h4 id="连接到远程服务器"><a href="#连接到远程服务器" class="headerlink" title="连接到远程服务器"></a>连接到远程服务器</h4><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">btnConnect_Click</span>(<span class="params"><span class="keyword">object</span> sender, RoutedEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建负责通信的Socket</span></span><br><span class="line">        socketSend = <span class="keyword">new</span> Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);</span><br><span class="line">        IPAddress ip = IPAddress.Parse(txtServer.Text);</span><br><span class="line">        IPEndPoint point = <span class="keyword">new</span> IPEndPoint(ip, Convert.ToInt32(txtPort.Text));</span><br><span class="line">        <span class="comment">//获得要连接的远程服务器应用程序的IP地址和端口号</span></span><br><span class="line">        socketSend.Connect(point);</span><br><span class="line">        ShowMsg(<span class="string">"连接成功"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启一个新的线程不停地接收服务器端发来的消息</span></span><br><span class="line">        Thread th = <span class="keyword">new</span> Thread(Receive);</span><br><span class="line">        th.IsBackground = <span class="literal">true</span>;</span><br><span class="line">        th.Start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="接收服务器发送的消息"><a href="#接收服务器发送的消息" class="headerlink" title="接收服务器发送的消息"></a>接收服务器发送的消息</h4><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 不停地接收服务器发来的消息</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Receive</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">3</span>];</span><br><span class="line">            <span class="comment">//实际接收到的有效字节数</span></span><br><span class="line">            <span class="keyword">int</span> r = socketSend.Receive(buffer);</span><br><span class="line">            <span class="keyword">if</span> (r == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//表示发送的是文字消息</span></span><br><span class="line">            <span class="keyword">if</span> (buffer[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">string</span> str = Encoding.UTF8.GetString(buffer, <span class="number">1</span>, r - <span class="number">1</span>);</span><br><span class="line">                Dispatcher.BeginInvoke(DispatcherPriority.Normal, <span class="keyword">new</span> delegate1(ShowMsg), socketSend.RemoteEndPoint.ToString() + <span class="string">":"</span> + str);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (buffer[<span class="number">0</span>] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                SaveFileDialog sfd = <span class="keyword">new</span> SaveFileDialog();</span><br><span class="line">                sfd.InitialDirectory = <span class="string">@"C:\Users\Administrator\Desktop"</span>;</span><br><span class="line">                sfd.Title = <span class="string">"请选择要保存的文件"</span>;</span><br><span class="line">                sfd.Filter = <span class="string">"所有文件|*.*"</span>;</span><br><span class="line">                sfd.ShowDialog();</span><br><span class="line">                <span class="keyword">string</span> path = sfd.FileName;</span><br><span class="line">                <span class="keyword">using</span> (FileStream fsWrite = <span class="keyword">new</span> FileStream(path, FileMode.OpenOrCreate, FileAccess.Write))</span><br><span class="line">                &#123;</span><br><span class="line">                    fsWrite.Write(buffer, <span class="number">1</span>, r - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                MessageBox.Show(<span class="string">"保存成功"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (buffer[<span class="number">0</span>] == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//Shock();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="客户端给服务器发送消息"><a href="#客户端给服务器发送消息" class="headerlink" title="客户端给服务器发送消息"></a>客户端给服务器发送消息</h4><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 客户端给服务器发送消息</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="sender"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="e"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">btnSendMsg_Click</span>(<span class="params"><span class="keyword">object</span> sender, RoutedEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span> str = txtSendMsg.Text.Trim();</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = Encoding.UTF8.GetBytes(str);</span><br><span class="line">    socketSend.Send(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>另附SocketDemo。Socket实现简单的服务器和客户端之间通信的WPF应用程序。</p>
<p>github地址：<a href="https://github.com/zhdaa/SocketDemo" target="_blank" rel="noopener">https://github.com/zhdaa/SocketDemo</a></p>

                <hr>
                

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2018/10/07/嫦娥/" data-toggle="tooltip" data-placement="top"
                           title="嫦娥">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2018/09/18/NET开源日志框架Log4Net详解/" data-toggle="tooltip" data-placement="top"
                           title=".NET开源日志框架Log4Net详解">Next Post &rarr;</a>
                    </li>
                    
                </ul>

                

                


                <!--加入新的评论系统-->
                

                

            </div>

            <div class="hidden-xs col-sm-3 toc-col">
                <div class="toc-wrap">
                    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#进程类"><span class="toc-text">进程类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#获得所有的进程"><span class="toc-text">获得所有的进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通过进程打开应用程序"><span class="toc-text">通过进程打开应用程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通过进程打开指定文件"><span class="toc-text">通过进程打开指定文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多线程"><span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#单线程带来的问题"><span class="toc-text">单线程带来的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要用多线程"><span class="toc-text">为什么要用多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#前台线程和后台线程"><span class="toc-text">前台线程和后台线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#产生线程的步骤"><span class="toc-text">产生线程的步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#跨线程访问"><span class="toc-text">跨线程访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread类的重要成员"><span class="toc-text">Thread类的重要成员</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Socket网络编程"><span class="toc-text">Socket网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概念"><span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP和UDP协议"><span class="toc-text">TCP和UDP协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#服务端Server"><span class="toc-text">服务端Server</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#主要思路"><span class="toc-text">主要思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建负责监听的Socket"><span class="toc-text">创建负责监听的Socket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#等待客户端连接，创建负责通信的Socket"><span class="toc-text">等待客户端连接，创建负责通信的Socket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#接收客户端发送的消息"><span class="toc-text">接收客户端发送的消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ShowMsg方法"><span class="toc-text">ShowMsg方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#服务器给客户端发送消息"><span class="toc-text">服务器给客户端发送消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#选择文件"><span class="toc-text">选择文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#发送文件"><span class="toc-text">发送文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#发送震动"><span class="toc-text">发送震动</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#客户端Client"><span class="toc-text">客户端Client</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#主要思路-1"><span class="toc-text">主要思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#连接到远程服务器"><span class="toc-text">连接到远程服务器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#接收服务器发送的消息"><span class="toc-text">接收服务器发送的消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#客户端给服务器发送消息"><span class="toc-text">客户端给服务器发送消息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#完整代码"><span class="toc-text">完整代码</span></a></li></ol></li></ol>
                </div>
            </div>
        </div>

        <div class="row">
            <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5 class="text-center">
                        <a href="/tags/">FEATURED TAGS</a>
                    </h5>
                    <div class="tags">
                        
                        <a class="tag" href="/tags/#C#"
                           title="C#">C#</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <div style="margin-top: 20px;">
                    <h5 class="text-center">FRIENDS</h5>
                    <ul class="list-inline text-center">
                        
                        <li><a href="http://laibh.top">赖同学</a></li>
                        
                    </ul>
                </div>
                
            </div>
        </div>

    </div>
</article>







<!-- Footer -->
<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <br>
                <ul class="list-inline text-center">
                
                
                

                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/zhdaa">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Zhendong 2021
                    <br>
                    <span id="busuanzi_container_site_uv">本站访客数<span id="busuanzi_value_site_uv"></span>人次</span>
                    <br>
                    Theme by <a href="https://haojen.github.io/">Haojen Ma</a>
                </p>

            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/blog.js"></script>

<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://zhdaa.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>

<!-- Google Analytics -->



<!-- Baidu Tongji -->

<script>
    var _baId = '4cc1f2d8f3067386cc5cdb626a202900';
    // Originial
    var _hmt = _hmt || [];
    (function() {
        var hm = document.createElement("script");
        hm.src = "//hm.baidu.com/hm.js?" + _baId;
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>


<!-- swiftype -->
<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','','2.0.0');
</script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<!--wechat title img-->
<img class="wechat-title-img" src="/images/zhdaa-headimg.jpg">
<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"live2d-widget-model-hijiki"},"display":{"position":"left","width":100,"height":200},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>

</html>
