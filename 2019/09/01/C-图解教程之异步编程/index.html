<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="zhendong在github上的个人博客">
    <meta name="keyword" content="">
    <meta name="theme-color" content="#600090">
    <meta name="msapplication-navbutton-color" content="#600090">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="#600090">
    <link rel="shortcut icon" href="/images/favicon.ico">
    <link rel="alternate" type="application/atom+xml" title="Zhendong" href="/atom.xml">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css">
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.css">
    <title>
        
        C#图解教程之异步编程｜Zhendong&#39;s blog
        
    </title>

    <link rel="canonical" href="https://zhdaa.github.io/2019/09/01/C-图解教程之异步编程/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/blog-style.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">
</head>

<style>

    header.intro-header {
        background-image: url('/images/zhdaa-headimg.jpg')
    }
</style>
<!-- hack iOS CSS :active style -->
<body ontouchstart="" class="animated fadeIn">
<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top " id="nav-top" data-ispost = "true" data-istags="false
" data-ishome = "false" >
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand animated pulse" href="/">
                <span class="brand-logo">
                    Zhendong
                </span>
                's Blog
            </a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <!-- /.navbar-collapse -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
					
                    
                        
							
                        <li>
                            <a href="/Tags/">Tags</a>
                        </li>
							
						
                    
					
					
                </ul>
            </div>
        </div>
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
//    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>

<!-- Main Content -->

<!--only post-->


<img class="wechat-title-img"
     src="/images/post-ocean.jpg">


<style>
    
    header.intro-header {
        background-image: url('/images/post-ocean.jpg')
    }

    
</style>

<header class="intro-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <div class="post-heading">
                    <h1>C#图解教程之异步编程</h1>
                    
                    <span class="meta">
                         作者 Zhendong Ho
                        <span>
                          日期 2019-09-01
                         </span>
                    </span>
                    <div class="tags text-center">
                        
                        <a class="tag" href="/tags/#C#"
                           title="C#">C#</a>
                        
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="post-title-haojen">
        <span>
            C#图解教程之异步编程
        </span>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <!-- Post Container -->
            <div class="col-lg-8 col-lg-offset-1 col-sm-9 post-container">
                <h2 id="什么是异步"><a href="#什么是异步" class="headerlink" title="什么是异步"></a>什么是异步</h2><p>启动程序时，系统会在内存中创建一个新的<strong>进程</strong>。进程是构成运行程序的<strong>资源的集合</strong>。这些资源包括<strong>虚地址空间</strong>、<strong>文件句柄</strong>和许多其他程序运行所需的东西。</p>
<p>在进程内部，系统创建了一个称为<strong>线程的内核（kernel）对象</strong>，它代表了真正执行的程序。一旦进程建立，系统会在Main方法的第一行语句处就开始线程的执行。</p>
<p><strong>有关线程的知识</strong>：</p>
<ul>
<li>默认情况下，<strong>一个进程只包含一个线程</strong>，从程序的开始一直执行到结束。</li>
<li><strong>线程可以派生其他线程</strong>，因此在任何时刻，一个进程都可能<strong>包含不同状态的多个线程</strong>，来执行程序的<strong>不同部分</strong>。</li>
<li>如果一个进程有多个线程，它们将<strong>共享进程的资源</strong>。</li>
<li>系统为处理器执行所规划的单元是<strong>线程</strong>。</li>
</ul>
<p>在异步程序中，程序代码<strong>不需要按照编写时的顺序</strong>严格执行。C#5.0引入了构建异步方法的<strong>async和await关键字</strong>。</p>
<h3 id="使用异步和不使用异步的区别"><a href="#使用异步和不使用异步的区别" class="headerlink" title="使用异步和不使用异步的区别"></a>使用异步和不使用异步的区别</h3><p>例：不使用异步的示例。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"><span class="keyword">using</span> System.Net;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyDownloadString</span></span><br><span class="line">&#123;</span><br><span class="line">    Stopwatch sw = <span class="keyword">new</span> Stopwatch();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoRun</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> LargeNumber = <span class="number">6</span>_000_000;</span><br><span class="line">        sw.Start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> t1 = CountCharacters(<span class="number">1</span>, <span class="string">"http://www.microsoft.com"</span>);</span><br><span class="line">        <span class="keyword">int</span> t2 = CountCharacters(<span class="number">2</span>, <span class="string">"http://www.illustratedcsharp.com"</span>);</span><br><span class="line"></span><br><span class="line">        CountToALargeNumber(<span class="number">1</span>, LargeNumber);</span><br><span class="line">        CountToALargeNumber(<span class="number">2</span>, LargeNumber);</span><br><span class="line">        CountToALargeNumber(<span class="number">3</span>, LargeNumber);</span><br><span class="line">        CountToALargeNumber(<span class="number">4</span>, LargeNumber);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">"Chars in http://www.microsoft.com        : &#123;0&#125;"</span>, t1);</span><br><span class="line">        Console.WriteLine(<span class="string">"Chars in http://www.illustratedcsharp.com: &#123;0&#125;"</span>, t2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 下载某网站的内容，返回该网站包含的字符数</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="id"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="uriString"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">CountCharacters</span>(<span class="params"><span class="keyword">int</span> id, <span class="keyword">string</span> uriString</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        WebClient wc1 = <span class="keyword">new</span> WebClient();</span><br><span class="line">        Console.WriteLine(<span class="string">"Starting call &#123;0&#125;    :   &#123;1, 4:N0&#125; ms"</span>, id, sw.Elapsed.TotalMilliseconds);</span><br><span class="line">        <span class="keyword">string</span> result = wc1.DownloadString(<span class="keyword">new</span> Uri(uriString));</span><br><span class="line">        Console.WriteLine(<span class="string">"  Call &#123;0&#125; completed:    &#123;1, 4:N0&#125; ms"</span>, id, sw.Elapsed.TotalMilliseconds);</span><br><span class="line">        <span class="keyword">return</span> result.Length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 执行一个消耗一定时间的任务</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="id"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="value"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CountToALargeNumber</span>(<span class="params"><span class="keyword">int</span> id, <span class="keyword">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="keyword">value</span>; i++) ;</span><br><span class="line">        Console.WriteLine(<span class="string">" End counting &#123;0&#125;    :   &#123;1, 4:N0&#125; ms"</span>, id, sw.Elapsed.TotalMilliseconds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        MyDownloadString ds = <span class="keyword">new</span> MyDownloadString();</span><br><span class="line">        ds.DoRun();</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下所示，计时以毫秒为单位。每次运行的结果可能不同：</p>
<p><img src="20-r1.png" alt=""></p>
<p><strong>下图总结了输出结果</strong>。Call1和Call2占用了大部分时间，而且都浪费在<strong>等待网站的响应</strong>上。</p>
<p><img src="20-1.jpg" alt=""></p>
<p>如果我们能初始化两个<strong>CountCharacter</strong>调用，无需等待结果，而是直接执行4个<strong>CountToALargeNumber</strong>调用，然后在两个<strong>CountCharacter方法调用结束时再获取结果</strong>，就可以显著地提高性能。这里可以使用<strong>C#的async/await特性</strong>。</p>
<ul>
<li>当DoRun调用<strong>CountCharactersAsync</strong>时，<strong>CountCharactersAsync将立即返回</strong>，然后才真正<strong>开始下载字符</strong>。它向调用方法返回的是一个<strong>Task&lt;int&gt;类型的占位符对象</strong>，表示它计划进行的工作。这个占位符最终将<strong>“返回”一个int</strong>。</li>
<li>这使得DoRun<strong>不用等待实际工作完成</strong>就可以继续执行。下一条语句是再次调用<strong>CountCharactersAsync</strong>，同样会返回一个<strong>Task&lt;int&gt;对象</strong>。</li>
<li>接着，DoRun可以继续执行，调用4次<strong>CountToALargeNumber</strong>，同时<strong>CountCharactersAsync</strong>的两次调用<strong>继续它们的工作</strong>——基本上是等待。</li>
<li>DoRun的<strong>最后两行</strong>从<strong>CountCharactersAsync</strong>调用返回的<strong>Tasks中获取结果</strong>。如果还没有结果，将阻塞并等待。</li>
</ul>
<p>例：使用异步示例。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"><span class="keyword">using</span> System.Net;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyDownloadString</span></span><br><span class="line">&#123;</span><br><span class="line">    Stopwatch sw = <span class="keyword">new</span> Stopwatch();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoRun</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> LargeNumber = <span class="number">6</span>_000_000;</span><br><span class="line">        sw.Start();</span><br><span class="line"></span><br><span class="line">        Task&lt;<span class="keyword">int</span>&gt; t1 = CountCharactersAsync(<span class="number">1</span>, <span class="string">"http://www.microsoft.com"</span>);      <span class="comment">// 保存结果的对象</span></span><br><span class="line">        Task&lt;<span class="keyword">int</span>&gt; t2 = CountCharactersAsync(<span class="number">2</span>, <span class="string">"http://www.illustratedcsharp.com"</span>);  <span class="comment">// 保存结果的对象</span></span><br><span class="line"></span><br><span class="line">        CountToALargeNumber(<span class="number">1</span>, LargeNumber);</span><br><span class="line">        CountToALargeNumber(<span class="number">2</span>, LargeNumber);</span><br><span class="line">        CountToALargeNumber(<span class="number">3</span>, LargeNumber);</span><br><span class="line">        CountToALargeNumber(<span class="number">4</span>, LargeNumber);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">"Chars in http://www.microsoft.com        : &#123;0&#125;"</span>, t1.Result); <span class="comment">// 获取结果</span></span><br><span class="line">        Console.WriteLine(<span class="string">"Chars in http://www.illustratedcsharp.com: &#123;0&#125;"</span>, t2.Result); <span class="comment">// 获取结果</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task&lt;<span class="keyword">int</span>&gt; <span class="title">CountCharactersAsync</span>(<span class="params"><span class="keyword">int</span> id, <span class="keyword">string</span> site</span>)   <span class="comment">// Task&lt;int&gt;表示正在执行的工作，最终将返回int</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        WebClient wc = <span class="keyword">new</span> WebClient();</span><br><span class="line">        Console.WriteLine(<span class="string">"Starting call &#123;0&#125;    :   &#123;1, 4:N0&#125; ms"</span>, id, sw.Elapsed.TotalMilliseconds);</span><br><span class="line">        <span class="keyword">string</span> result = <span class="keyword">await</span> wc.DownloadStringTaskAsync(<span class="keyword">new</span> Uri(site));	<span class="comment">// 该操作需要等待</span></span><br><span class="line">        Console.WriteLine(<span class="string">"  Call &#123;0&#125; completed:    &#123;1, 4:N0&#125; ms"</span>, id, sw.Elapsed.TotalMilliseconds);</span><br><span class="line">        <span class="keyword">return</span> result.Length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CountToALargeNumber</span>(<span class="params"><span class="keyword">int</span> id, <span class="keyword">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="keyword">value</span>; i++) ;</span><br><span class="line">        Console.WriteLine(<span class="string">" End counting &#123;0&#125;    :   &#123;1, 4:N0&#125; ms"</span>, id, sw.Elapsed.TotalMilliseconds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<p><img src="20-r2.png" alt=""></p>
<p><strong>下图总结了输出结果</strong>，展示了修改后的程序的时间轴。新版程序比旧版<strong>快了32%</strong>！这是因为<strong>CountToALargeNumber</strong>的4次调用是在<strong>CountCharactersAsync</strong>方法调用<strong>等待网站响应的时候进行的</strong>。</p>
<p><img src="20-2.jpg" alt=""></p>
<h2 id="async-await特性的结构"><a href="#async-await特性的结构" class="headerlink" title="async/await特性的结构"></a>async/await特性的结构</h2><p>如果一个程序调用某个方法，<strong>等待其执行所有处理</strong>后才继续执行，我们就称这一的方法是<strong>同步的</strong>，这是<strong>默认的</strong>。</p>
<p>相反，<strong>异步的方法在处理完成之前就返回到调用方法。</strong></p>
<p>C#的<strong>async/await特性</strong>可以创建并使用异步方法。该特性由<strong>三个部分</strong>组成：</p>
<ul>
<li><strong>调用方法（calling method）</strong>：该方法<strong>调用异步方法</strong>，然后在异步方法执行其任务的时候继续执行。</li>
<li><strong>异步（async）方法</strong>：该方法<strong>异步执行其工作</strong>，然后立即返回到调用方法。</li>
<li><strong>await表达式</strong>：用于异步方法内部，<strong>指明需要异步执行的任务</strong>。一个异步方法可以包含<strong>任意多个await表达式</strong>，不过如果一个都不包含的话编译器会发出警告。</li>
</ul>
<h3 id="异步方法的语法"><a href="#异步方法的语法" class="headerlink" title="异步方法的语法"></a>异步方法的语法</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">DoAsyncStuff</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 异步方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task&lt;<span class="keyword">int</span>&gt; <span class="title">CalculateSumAsync</span>(<span class="params"><span class="keyword">int</span> i1, <span class="keyword">int</span> i2</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="keyword">await</span> TaskEx.Run(() = &gt; GetSum(i1, i2));	<span class="comment">// await表达式</span></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用方法</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Task&lt;<span class="keyword">int</span>&gt; <span class="keyword">value</span> = DoAsyncStuff.CalculateSumAsync(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="什么是异步方法"><a href="#什么是异步方法" class="headerlink" title="什么是异步方法"></a>什么是异步方法</h2><p>异步方法在完成其工作之前即返回到调用方法，然后在调用方法继续执行的时候完成其工作。</p>
<p><strong>异步方法语法特点</strong>：</p>
<ul>
<li>方法头中<strong>包含async方法修饰符</strong>。</li>
<li>包含<strong>一个或多个await表达式</strong>，表示可以异步完成的任务。</li>
<li>必须具有三种返回类型，<strong>void</strong>、<strong>Task</strong>、<strong>Task&lt;T&gt;</strong>。Task和Task&lt;T&gt;的返回对象表示将在未来完成的工作。</li>
<li>异步方法的参数可以为任何类型任意数量，但<strong>不能为out或ref参数</strong>。</li>
<li>异步方法的名称应该<strong>以Async为后缀命名</strong>。</li>
<li>除了方法以外，<strong>Lambda表达式和匿名方法</strong>也可以作为<strong>异步对象</strong>。</li>
</ul>
<p>例：异步方法示例。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">关键字  返回类型</span><br><span class="line">  ↓       ↓</span><br><span class="line"><span class="function"><span class="keyword">async</span> Task&lt;<span class="keyword">int</span>&gt; <span class="title">CountCharactersAsync</span>(<span class="params"><span class="keyword">int</span> id, <span class="keyword">string</span> site</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">"Starting CountCharacters"</span>);</span><br><span class="line">    WebClient wc = <span class="keyword">new</span> WebClient();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">string</span> result = <span class="keyword">await</span> wc.DownloadStringTaskAsync(<span class="keyword">new</span> Uri(site));	<span class="comment">// await表达式</span></span><br><span class="line">    </span><br><span class="line">    Console.WriteLine(<span class="string">"CountCharacters Completed"</span>);</span><br><span class="line">    <span class="keyword">return</span> result.Length;	<span class="comment">// 返回语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>异步方法的组成</strong>：</p>
<ul>
<li>异步方法在方法头中<strong>必须包含async关键字</strong>，而且必须出现在<strong>返回类型之前</strong>。</li>
<li>该修饰符只是<strong>标识</strong>该方法包含<strong>一个或多个await表达式</strong>。本身并不能创建任何异步操作。</li>
<li>async关键字是一个<strong>上下文关键字</strong>，即除了作为<strong>方法修饰符</strong>之外，<strong>async还可用作标识符</strong>。</li>
</ul>
<p><strong>三种返回类型</strong>：</p>
<p><strong>Task&lt;T&gt;</strong>：如果调用方法要<strong>从调用中获取一个T类型的值</strong>，异步方法的<strong>返回类型就必须是Task&lt;T&gt;</strong>。调用方法将通过读取Task的Result属性来获取这个T类型的值。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Task&lt;<span class="keyword">int</span>&gt; <span class="keyword">value</span> = DoStuff.CalculateSumAsync(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">Console.WriteLine(<span class="string">"Value: &#123;0&#125;"</span>, <span class="keyword">value</span>.Result);</span><br></pre></td></tr></table></figure>
<p><strong>Task</strong>：如果调用方法<strong>不需要从异步方法中返回某个值</strong>，但需要检查异步方法的状态，那么异步方法可以<strong>返回一个Task类型</strong>的对象。这时，即使异步方法中出现了<strong>return语句</strong>，<strong>也不会返回任何东西</strong>。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Task someTask = DoStuff.CalculateSumAsync(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">someTask.Wait();</span><br></pre></td></tr></table></figure>
<p><strong>void</strong>：如果调用方法仅仅想执行异步方法，而不需要与它做<strong>任何进一步的交互时</strong>（<strong>调用并忘记[fire and forget]</strong>），异步方法可以<strong>返回void类型</strong>。这时，即使异步方法中出现<strong>return语句</strong>，<strong>也不会返回任何东西</strong>。</p>
<p><strong>注意</strong>：任何返回<strong>Task&lt;T&gt;</strong>类型的异步方法，其返回值必须为T类型或可以隐式转换为T的类型。</p>
<p>例：使用返回Task&lt;int&gt;对象的异步方法。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Task&lt;<span class="keyword">int</span>&gt; <span class="keyword">value</span> = DoAsyncStuff.CalculateSumAsync(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 处理其他事情</span></span><br><span class="line">        Console.WriteLine(<span class="string">"Value: &#123;0&#125;"</span>, <span class="keyword">value</span>.Result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">DoAsyncStuff</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task&lt;<span class="keyword">int</span>&gt; <span class="title">CalculateSumAsync</span>(<span class="params"><span class="keyword">int</span> i1, <span class="keyword">int</span> i2</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="keyword">await</span> Task.Run(() =&gt; GetSum(i1, i2));</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetSum</span>(<span class="params"><span class="keyword">int</span> i1, <span class="keyword">int</span> i2</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i1 + i2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例：使用返回Task对象的异步方法。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Task someTask = DoAsyncStuff.CalculateSumAsync(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 处理其他事情</span></span><br><span class="line">        someTask.wait();</span><br><span class="line">        Console.WriteLine(<span class="string">"Async stuff is done"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">DoAsyncStuff</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">CalculateSumAsync</span>(<span class="params"><span class="keyword">int</span> i1, <span class="keyword">int</span> i2</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">value</span> = <span class="keyword">await</span> Task.Run(() =&gt; GetSum(i1, i2));</span><br><span class="line">        Console.WriteLine(<span class="string">"Value: &#123;0&#125;"</span>, <span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetSum</span>(<span class="params"><span class="keyword">int</span> i1, <span class="keyword">int</span> i2</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i1 + i2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例：使用“调用并忘记”的异步方法。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        DoAsyncStuff.CalculateSumAsync(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 处理其他事情</span></span><br><span class="line">        Thread.Sleep(<span class="number">200</span>);	<span class="comment">// 由于使用了Thread.Sleep方法来暂停当前线程，所以异步方法完成时它还没完成</span></span><br><span class="line">        Console.WriteLine(<span class="string">"Program Exiting"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">DoAsyncStuff</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">CalculateSumAsync</span>(<span class="params"><span class="keyword">int</span> i1, <span class="keyword">int</span> i2</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">value</span> = <span class="keyword">await</span> Task.Run(() =&gt; GetSum(i1, i2));</span><br><span class="line">        Console.WriteLine(<span class="string">"Value: &#123;0&#125;"</span>, <span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetSum</span>(<span class="params"><span class="keyword">int</span> i1, <span class="keyword">int</span> i2</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i1 + i2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="异步方法的控制流"><a href="#异步方法的控制流" class="headerlink" title="异步方法的控制流"></a>异步方法的控制流</h3><p>异步方法的结构包含<strong>三个不同的区域</strong>：</p>
<ul>
<li><strong>await表达式之前的部分</strong>：从方法开头到第一个await表达式之间的所有代码。这部分应该只包含<strong>少量且无需长时间处理</strong>的代码。</li>
<li><strong>await表达式</strong>：表示将被异步执行的任务。</li>
<li><strong>后续部分</strong>：在await表达式之后出现的方法中的其余代码。包括其执行环境，如所在线程信息、目前作用域内的变量值，以及当await表达式完成后要重新执行所需的其他信息。</li>
</ul>
<p><img src="20-8.jpg" alt=""></p>
<p><strong>注意</strong>：当达到<strong>await表达式</strong>时，<strong>异步方法将控制返回到调用方法</strong>。如果方法的返回类型为Task或Task&lt;T&gt;类型，将创建一个Task对象，表示需异步完成的任务和后续，然后<strong>将该Task返回到调用方法</strong>。</p>
<p>目前有<strong>两个控制流</strong>：<strong>异步方法内的</strong>和<strong>调用方法内的</strong>。异步方法内的代码完成以下工作：</p>
<ul>
<li>异步执行await表达式的空闲任务。</li>
<li>当await表达式完成时，执行后续部分。</li>
<li>当后续部分遇到return语句或达到方法末尾时，根据返回类型<strong>void、Task、Task&lt;T&gt;设置对应的属性并退出控制流</strong>。</li>
</ul>
<p>同时，<strong>调用方法中的代码将继续其进程</strong>，<strong>从异步方法获取Task对象</strong>。当需要其实际值时，就<strong>引用Task对象的Result属性</strong>。届时，如果异步方法设置了该属性，调用方法就能获得该值并继续。否则，<strong>将暂停并等待该属性被设置，然后再继续执行</strong>。</p>
<p><img src="20-9.jpg" alt=""></p>
<h3 id="await表达式"><a href="#await表达式" class="headerlink" title="await表达式"></a>await表达式</h3><p>await表达式指定了一个异步执行的任务。</p>
<p>语法：由<strong>await关键字</strong>和一个<strong>空闲对象</strong>（称为任务）组成。</p>
<p>这个任务可能是一个Task类型的对象，也可能不是。默认情况下，这个任务在当前线程异步运行。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> task</span><br></pre></td></tr></table></figure>
<p>一个<strong>空闲对象</strong>即是一个<strong>awaitable类型的实例</strong>。awaitable类型是指<strong>包含GetAwaiter方法</strong>的类型，该方法没有参数，返回一个称为<strong>awaiter类型的对象</strong>。awaiter类型包含以下成员。</p>
<ul>
<li>bool isCompleted { get; }</li>
<li>void OnCompleted(Action);</li>
</ul>
<p>它还包含以下成员之一：</p>
<ul>
<li>void GetResult();</li>
<li>T GetResult();  // T为任意类型</li>
</ul>
<p>然而实际上，并<strong>不需要构建awaitable</strong>。应该使用<strong>Task类</strong>，它是awaitable类型。</p>
<h4 id="Task-Run方法"><a href="#Task-Run方法" class="headerlink" title="Task.Run方法"></a>Task.Run方法</h4><p>尽管目前BCL中存在许多<strong>返回Task&lt;T&gt;类型对象</strong>的方法，但是也可以<strong>编写自己的方法</strong>。</p>
<p>最简单的方式是在方法中使用<strong>Task.Run方法</strong>来创建一个Task。<strong>Task.Run是在不同的线程上运行方法的</strong>。</p>
<p>例：Task.Run方法接受一个Func&lt;TReturn&gt;委托作为参数。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Get10</span>(<span class="params"></span>)	<span class="comment">// 与Func&lt;int&gt;兼容</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">DoWorkAsync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Func&lt;<span class="keyword">int</span>&gt; ten = <span class="keyword">new</span> Func&lt;<span class="keyword">int</span>&gt;(Get10);</span><br><span class="line">        <span class="keyword">int</span> a = <span class="keyword">await</span> Task.Run(ten);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> b = <span class="keyword">await</span> Task.Run(<span class="keyword">new</span> Func&lt;<span class="keyword">int</span>&gt;(Get10));	<span class="comment">// 在参数列表创建委托</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> c = <span class="keyword">await</span> Task.Run(() =&gt; &#123; <span class="keyword">return</span> <span class="number">10</span>; &#125;);	<span class="comment">// Lambda表达式隐式转换为Func&lt;int&gt;委托</span></span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">"&#123;0&#125; &#123;1&#125; &#123;2&#125;"</span>, a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Task t = (<span class="keyword">new</span> MyClass()).DoWorkAsync();</span><br><span class="line">        t.Wait();	<span class="comment">// 10 10 10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中，使用的<strong>Task.Run的签名</strong>以<strong>Func&lt;TResult&gt;</strong>为参数。该方法共<strong>8个重载</strong>如下所示：</p>
<p><img src="20-t1.jpg" alt=""></p>
<p>可能用到的4个委托类型的签名：</p>
<p><img src="20-t2.jpg" alt=""></p>
<p>例：使用Task.Run方法来运行4种不同的委托类型。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">DoWorkAsync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">await</span> Task.Run(() =&gt; Console.WriteLine(<span class="number">5.</span>ToString()));  <span class="comment">// Action</span></span><br><span class="line"></span><br><span class="line">        Console.WriteLine((<span class="keyword">await</span> Task.Run(() =&gt; <span class="number">6</span>)).ToString());  <span class="comment">// TResult Func()</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> Task.Run(() =&gt; Task.Run(() =&gt; Console.WriteLine(<span class="number">7.</span>ToString())));  <span class="comment">// Task Func()</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">value</span> = <span class="keyword">await</span> Task.Run(() =&gt; Task.Run(() =&gt; <span class="number">8</span>));    <span class="comment">// Task&lt;TResult&gt; Func()</span></span><br><span class="line">        Console.WriteLine(<span class="keyword">value</span>.ToString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Task t = MyClass.DoWorkAsync();</span><br><span class="line">        t.Wait();	<span class="comment">// 5 6 7 8</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任何可以使用表达式的地方，都可以使用<strong>await表达式</strong>，只要位于<strong>异步方法内</strong>。上面的代码中：</p>
<ul>
<li>第一个和第三个实例将await表达式用作<strong>语句</strong>。</li>
<li>第二个实例将await表达式用作<strong>WriteLine方法的参数</strong>。</li>
<li>第四个实例将await表达式用作<strong>赋值语句的右端</strong>。</li>
</ul>
<p>例：用可接受的Func委托的形式创建一个Lambda函数。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetSum</span>(<span class="params"><span class="keyword">int</span> i1, <span class="keyword">int</span> i2</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i1 + i2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">DoWorkAsync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">value</span> = <span class="keyword">await</span> Task.Run(() =&gt; GetSum(<span class="number">5</span>, <span class="number">6</span>));	<span class="comment">// TResult Func()</span></span><br><span class="line">        Console.WriteLine(<span class="keyword">value</span>.ToString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Task t = MyClass.DoWorkAsync();</span><br><span class="line">        t.Wait();	<span class="comment">// 11</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

                <hr>
                

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2019/09/09/C-各个版本的新特性/" data-toggle="tooltip" data-placement="top"
                           title="C#各个版本的新特性">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2019/08/26/C-图解教程之LINQ/" data-toggle="tooltip" data-placement="top"
                           title="C#图解教程之LINQ">Next Post &rarr;</a>
                    </li>
                    
                </ul>

                

                


                <!--加入新的评论系统-->
                

                

            </div>

            <div class="hidden-xs col-sm-3 toc-col">
                <div class="toc-wrap">
                    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是异步"><span class="toc-text">什么是异步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用异步和不使用异步的区别"><span class="toc-text">使用异步和不使用异步的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#async-await特性的结构"><span class="toc-text">async/await特性的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#异步方法的语法"><span class="toc-text">异步方法的语法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是异步方法"><span class="toc-text">什么是异步方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#异步方法的控制流"><span class="toc-text">异步方法的控制流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#await表达式"><span class="toc-text">await表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Task-Run方法"><span class="toc-text">Task.Run方法</span></a></li></ol></li></ol></li></ol>
                </div>
            </div>
        </div>

        <div class="row">
            <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5 class="text-center">
                        <a href="/tags/">FEATURED TAGS</a>
                    </h5>
                    <div class="tags">
                        
                        <a class="tag" href="/tags/#C#"
                           title="C#">C#</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <div style="margin-top: 20px;">
                    <h5 class="text-center">FRIENDS</h5>
                    <ul class="list-inline text-center">
                        
                        <li><a href="http://laibh.top">赖同学</a></li>
                        
                    </ul>
                </div>
                
            </div>
        </div>

    </div>
</article>







<!-- Footer -->
<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <br>
                <ul class="list-inline text-center">
                
                
                

                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/zhdaa">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Zhendong 2021
                    <br>
                    <span id="busuanzi_container_site_uv">本站访客数<span id="busuanzi_value_site_uv"></span>人次</span>
                    <br>
                    Theme by <a href="https://haojen.github.io/">Haojen Ma</a>
                </p>

            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/blog.js"></script>

<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://zhdaa.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>

<!-- Google Analytics -->



<!-- Baidu Tongji -->

<script>
    var _baId = '4cc1f2d8f3067386cc5cdb626a202900';
    // Originial
    var _hmt = _hmt || [];
    (function() {
        var hm = document.createElement("script");
        hm.src = "//hm.baidu.com/hm.js?" + _baId;
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>


<!-- swiftype -->
<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','','2.0.0');
</script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<!--wechat title img-->
<img class="wechat-title-img" src="/images/zhdaa-headimg.jpg">
<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"live2d-widget-model-hijiki"},"display":{"position":"left","width":100,"height":200},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>

</html>
